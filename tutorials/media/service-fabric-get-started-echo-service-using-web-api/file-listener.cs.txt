using System;
using System.Collections.Generic;
using System.Fabric;
using System.Fabric.Description;
using System.Threading;
using System.Threading.Tasks;
using System.Web.Http;
using System.Web.Http.Dependencies;
using Microsoft.Owin.Hosting;
using Microsoft.ServiceFabric.Services;
using Owin;

namespace Echo
{
	internal class WebApiListener : ICommunicationListener
	{
		// add owin selfhost webapi by:
		// Install-Package Microsoft.AspNet.WebApi.OwinSelfHost 

		/// <summary>
		/// address provided to Service Fabric for endpoint resolution
		/// </summary>
		public string Address { get; private set; }

		/// <summary>
		/// prefix provided to Web Api listener for local endpoint
		/// </summary>
		public string Prefix { get; private set; }

		public WebApiListener()
		{
			// no state manager required
		}

		static readonly string LocalNode = FabricRuntime.GetNodeContext().IPAddressOrFQDN;
		public void Initialize(ServiceInitializationParameters sip)
		{
			this.Address = GetAddress(sip);
		}

		public async Task<string> OpenAsync(CancellationToken cancellationToken)
		{
			// start the web server and the web socket listener
			await Start();
			ServiceEventSource.Current.Info("Service is now listening on: " + this.Address);
			return this.Address;
		}

		public Task CloseAsync(CancellationToken cancellationToken)
		{
			Stop();
			return Task.FromResult<bool>(true);
		}

		public void Abort()
		{
			Stop();
		}

		static EndpointResourceDescription GetInputEndpoint(ServiceInitializationParameters sip)
		{
			foreach (var erd in sip.CodePackageActivationContext.GetEndpoints())
			{
				if (erd.EndpointType == EndpointType.Input)
					return erd;
			}

			ServiceEventSource.Current.Error("No input endpoint found");
			throw new ApplicationException("No input endpoint found");
		}

		static long GetId(ServiceInitializationParameters sip)
		{
			if (sip is StatefulServiceInitializationParameters)
				return ((StatefulServiceInitializationParameters)sip).ReplicaId;
			return ((StatelessServiceInitializationParameters)sip).InstanceId;
		}

		static string GetAddress(ServiceInitializationParameters sip)
		{
			if (sip is StatefulServiceInitializationParameters)
			{
				var erd = GetInputEndpoint(sip);
				var id = GetId(sip);
				return erd.Protocol + "://" + LocalNode + ":" + erd.Port + "/"
					+ id + "/" + sip.PartitionId + "/";
			}

			var config = GetConfig(sip);
			return config.Protocol + "://" + LocalNode + ":" + config.Port + "/";
		}

		static ProtocolPort GetConfig(ServiceInitializationParameters sip)
		{
			ProtocolPort p = new ProtocolPort();
            if (sip.CodePackageActivationContext.GetConfigurationPackageNames().Contains("Config"))
            {
                var config = sip.CodePackageActivationContext.GetConfigurationPackageObject("Config");

				var service = config.Settings.Sections["Service"];
				if (service != null)
				{
					var portParam = service.Parameters["Port"];
					if (portParam != null)
						int.TryParse(portParam.Value, out p.Port);

					var protocolParam = service.Parameters["Protocol"];
					if (protocolParam != null)
						p.Protocol = protocolParam.Value;

                    ServiceEventSource.Current.Info("Loaded Config settings: Port=" + p.Port + " Protocol=" + p.Protocol);
                }
                else
                {
                    ServiceEventSource.Current.Info("No Service section found");
                }
            }
            else
            {
                ServiceEventSource.Current.Info("No config found");
            }


			return p;
		}

		class ProtocolPort
		{
			public string Protocol = "http";
			public int Port = 80;
		}

		SemaphoreSlim webEvent = new SemaphoreSlim(1);
		bool webIsRunning = false;
		Task webTask = null;
		async Task Start()
		{
			Uri u = new Uri(this.Address);
			this.Prefix = u.Scheme + "://+:" + u.Port + u.LocalPath;
			await this.webEvent.WaitAsync();

			webTask = Task.Run(async () =>
			{
				using (WebApp.Start(this.Prefix, appBuilder => Configuration(appBuilder)))
				{
					webIsRunning = true;
					await webEvent.WaitAsync();
				}

				webIsRunning = false;
			});
		}

		void Stop()
		{
			if (webIsRunning)
				webEvent.Release();
		}

		void Configuration(IAppBuilder appBuilder)
		{
			var config = new HttpConfiguration();
			config.MapHttpAttributeRoutes();
			appBuilder.UseWebApi(config);
		}
	}
}

