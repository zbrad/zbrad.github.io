<properties 
   pageTitle="echo-service-using-web-api"
   description="This tutorial goes into details on how to create a Microsoft Azure Service Fabric application that provides an echo request service using Web API" 
   services="service-fabric" 
   documentationCenter=".net" 
   authors="zbrad" 
   manager="mike.andrews" 
   editor="vturcek" />

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="multiple" 
   ms.date="04/13/2015"
   ms.author="brad.merrill"/>

# Echo service using Web API

This tutorial goes into details on how to create a Microsoft Azure Service Fabric application that provides an echo request service using Web API.
The echo service receives the Web API requests, and replies with updated text in the response body as the echo response.

Each request can be handled independently without needing to consult or maintain a context across multiple requests. For example, a unit converter converts measurements to different units given a scalar value and two units. The inputs are sufficient for the service to carry out the required operation independently. The request is not affected by any historical requests, nor other instances of the service.

## Create New Fabric Stateless Service Project

1. Launch Visual Studio 2015 CTP 6 as **Administrator**, and create a new **Stateless Service** Project named **Echo**.
![][15]
  You see 2 projects in the created solution:<br/>
![][16]<br/>
  The first is the service project (_Echo_), which contains the actual service implementation. The second project is the application project (_EchoApplication_), which contains the application manifest and a number of PowerShell scripts that help you to deploy your application.

1. Go to the NuGet package console (Tools->NuGet Package Manager->Package Manager Console) and enter the following command to add the Web API package:

		Install-Package Microsoft.AspNet.WebApi.OwinSelfHost

1. We're going to extend the events provided by the Visual Studio project template with a few more:

        [Event(4, Level = EventLevel.Informational, Message = "{0}")]
        public void Info(string message)
        {
            WriteEvent(4, message);
        }
        [Event(5, Level = EventLevel.Warning, Message = "{0}")]
        public void Warn(string message)
        {
            WriteEvent(5, message);
        }
        [Event(6, Level = EventLevel.Error, Message = "{0}")]
        public void Error(string message)
        {
            WriteEvent(6, message);
        }
This allows us to see error, warning, and information events generated by our service within the Visual Studio Diagnostic Events Viewer.

1. Open/Edit the *Service.cs* file in the _Echo_ project and replace the existing usings with:

        using System.Fabric.Services;

1. Remove the *RunAsync* method

1. Override the *CreateCommunicationListener* method with:

        protected override ICommunicationListener CreateCommunicationListener()
        {
                return new WebApiListener();
        }


1. save and close

## <a name="add_listener"></a> Add WebApiListener

To simplify the tutorial, we have created a _WebApiListener_.  For details of how this works, please see the [Create a Web Api Communication Listener Tutorial](WebApiListener.md).

For now, let's add the supplied WebApiListener:

1. Right-Click **Todo** project
2. Select add existing file
3. Browse to [Listener.cs][8]
4. click OK

## Add Settings.xml

1. Right-Click the `PackageRoot` folder and select _add a new subfolder_, call it *Config*
2. Right-Click the new *Config* folder and select _add new item_, select _XML file_, call it *Settings.xml*
3. Add this to the contents:

        <Section Name="Service">
            <Parameter Name="Protocol" Value="http" />
            <Parameter Name="Port" Value="8080" />
        </Section>

4. save and close

## Modify Manifests

1. Open/Edit the *ServiceManifest.xml* file in the _Echo_ projects
2. Add this line after the `CodePackage` element

        <ConfigPackage Name="Config" Version="1.0.0.0"/>

## Setup Http

Since we are listening to a port that is outside of Fabric control, we need to enable port access.  Start a Powershell session as administrator, and execute the script `HttpSetup.ps1` located in the _Echo_ project folder:

        .\Echo\HttpSetup.ps1

The output should look like:
![][11]

## <a name="testlocally"></a>Test locally

1. ![][5] If you haven't done so, you need to launch a local cluster first. Launch **Windows PowerShell** as **administrator** and execute the **DevClusterSetup.ps1** script under the **_DropLocation_\ClusterSetup\Local** folder.

	>**NOTE**: Your local cluster might be already running, in which case the script fails with many errors. If you want to clean up the local cluster, run the **CleanCluster.ps1** script under the same folder.

1. You can now build and deploy your service. Press **F5**, and your service is started. Once the service is running, you can see its output on the **Output** window of Visual Studio.
![][13]

1. You can now send data to the service, and receive a response, following the PowerShell
script:

        $app = Get-ServiceFabricApplication -ApplicationName 'fabric:/EchoApplication'
        $service = $app | Get-ServiceFabricService
        $partition = $service | Get-ServiceFabricPartition
        $instance = $partition | Get-ServiceFabricReplica
        $address = $instance.ReplicaAddress
        $echo = @{ value = "Hello" };
        $args = @{
            Uri = $address;
            Body = ConvertTo-Json $echo;
            Method = "Post";
            ContentType = "application/json";
            }
        Invoke-RestMethod @args
You should see a response like:
![][17]

1. Stop the program.

	>**NOTE**: To debug locally, set break points at the lines of interest. 

## Conclusion

In this tutorial, you created a stateless service, and tested it locally.

<!--image references-->
[1]: media/service-fabric-get-started-echo-service-using-web-api/add-services-ref.png
[2]: ./media/service-fabric-get-started-echo-service-using-web-api/app-output.png
[3]: ./media/service-fabric-get-started-echo-service-using-web-api/azure-portal.png
[4]: ./media/service-fabric-get-started-echo-service-using-web-api/azure-remote-connect.png
[5]: ./media/service-fabric-get-started-echo-service-using-web-api/change.png
[6]: ./media/service-fabric-get-started-echo-service-using-web-api/deploy.png
[7]: ./media/service-fabric-get-started-echo-service-using-web-api/file-applicationmanifest.xml.txt
[8]: ./media/service-fabric-get-started-echo-service-using-web-api/file-listener.cs.txt
[9]: ./media/service-fabric-get-started-echo-service-using-web-api/file-servicemanifest.xml.txt
[10]: ./media/service-fabric-get-started-echo-service-using-web-api/health-output.png
[11]: ./media/service-fabric-get-started-echo-service-using-web-api/http-setup-output.png
[12]: ./media/service-fabric-get-started-echo-service-using-web-api/info.png
[13]: ./media/service-fabric-get-started-echo-service-using-web-api/new-app-output.png
[14]: ./media/service-fabric-get-started-echo-service-using-web-api/new-container.png
[15]: ./media/service-fabric-get-started-echo-service-using-web-api/new-project.png
[16]: ./media/service-fabric-get-started-echo-service-using-web-api/new-sln.png
[17]: ./media/service-fabric-get-started-echo-service-using-web-api/response.png

