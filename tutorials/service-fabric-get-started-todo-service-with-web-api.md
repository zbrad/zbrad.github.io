<properties 
   pageTitle="todo-service-with-web-api"
   description="This tutorial goes into details on how to create a Microsoft Azure Service Fabric application that provides a todo service using Web API"
   services="service-fabric" 
   documentationCenter=".net" 
   authors="zbrad" 
   manager="mike.andrews" 
   editor="vturcek" />

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="multiple" 
   ms.date="04/13/2015"
   ms.author="brad.merrill"/>

# Implement a Todo service with Web API

This tutorial walks you through the steps of creating a stateful service that manages a to-do list. The service uses Service Fabric's reliable queue to save to-do items. And it uses ASP.NET Web API to provide a REST interface with add, remove and peek operations. It's recommend that you go through the [Tutorial: Getting Started with Service Fabric Web API Service (HelloWorldWebAPI)](Tutorials/HelloWorldWebAPI/Tutorial.md) before you start with this tutorial.

Tutorial segments

- [Create New Fabric Stateful Service Project](#create-new-fabric-stateful-service-project)
- [Add WebApiListener](#add-webapilistener)
- [Create TodoModels](#create-todo-models)
- [Create TodoController](#create-todocontroller)
- [Modify Manifests](#modify-manifests)
- [Test locally](#test-locally)

## Create New Fabric Stateful Service Project

1. Launch Visual Studio 2015 CTP 6 as **Administrator**, and create a new **Stateful Service** Project named **Todo**.
![][4] 
<br/>You see 2 projects in the created solution:<br/>
![][5]
<br/>
  The first is the service project **Todo**, which contains the actual service implementation. The second project is the application project **TodoApplication**, which contains the application manifest and a number of PowerShell scripts that help you to deploy your application.

1. Go to the NuGet package console (Tools->NuGet Package Manager->Package Manager Console) and enter the following command to add the Web API package:<br/>

        Install-Package Microsoft.AspNet.WebApi.OwinSelfHost

1. Extend the events provided by the Visual Studio project template with a few more:

        [Event(4, Level = EventLevel.Informational, Message = "{0}")]
        public void Info(string message)
        {
            WriteEvent(4, message);
        }

        [Event(5, Level = EventLevel.Warning, Message = "{0}")]
        public void Warn(string message)
        {
            WriteEvent(5, message);
        }

        [Event(6, Level = EventLevel.Error, Message = "{0}")]
        public void Error(string message)
        {
            WriteEvent(6, message);
        }
  These extra events allow us to see error, warning, and information events generated by our service within the Visual Studio Diagnostic Events Viewer.

1. Open the **Service.cs** file in the **Todo** project and replace the existing usings with:

        using System.Threading;
        using System.Threading.Tasks;
        using Microsoft.ServiceFabric.Services;

1. Replace the **RunAsync** implementation with the following code:

        protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            await base.RunAsync(cancellationToken);
        }

1. Override the **CreateCommunicationListener** method to return a Web API listener, which we'll implement in the next section:

        protected override ICommunicationListener CreateCommunicationListener()
        {
            return new WebApiListener(this.StateManager);
        }

1. Save changes.

## Add WebApiListener

To simplify the tutorial, we have created a _WebApiListener_ that utilizes the _IReliableObjectStateManager_ interface, and creates Web Api controllers that have a matching constructor, passing in the supplied interface.  For details of how this works, please see the [Create a Communication Listener using Web API Tutorial](service-fabric-get-started-communication-listener-with-web-api.md).

For now, let's add the supplied WebApiListener:

1. Right-Click **Todo** project
2. Select add existing file
3. Browse to [WebApiListener.cs][13]
4. click OK

## Create Todo Models

Models describe our messages received and sent.   For **Todo** we have defined messages for:
- TodoResult
  - contains the boolean result of an operation 
- TodoValue
  - contains a boolean result and a value of an operation
- TodoData
  - contains a value provided as a request
- TodoError
  - contains a boolean result and an error message

1. Add new class **TodoModels**
1. Replace contents with:

        namespace Todo
        {
            public sealed class TodoData
            {
            public string value { get; set; }
            }

            public class TodoResult
            {
            public bool result { get; set; }

            public TodoResult() { }

            public TodoResult(bool r)
            {
                this.result = r;
            }
            }

            public sealed class TodoError : TodoResult
            {
            public string error { get; set; }

            public TodoError() { }

            public TodoError(string message) : base(false)
            {
                this.error = message;
            }
            }

            public sealed class TodoValue : TodoResult
            {
            public string value { get; set; }

            public TodoValue() { }

            public TodoValue(string v) : base(true)
            {
                this.value = v;
            }
            }
        }

1. save the file

## Create TodoController

We can now implement our **TodoController** to receive requests via Web API.  In implementing our controller, we make use of the _IHttpActionResult_ interface to enable our controller for asynchronous use.

1. Add new class **TodoController**

1. Replace existing usings with:

        using System.Net.Http;
        using System.Threading;
        using System.Threading.Tasks;
        using System.Web.Http;
        using Microsoft.ServiceFabric.Data;
        using Microsoft.ServiceFabric.Data.Collections;

1. Within the **Todo** namespace, and a private class:

        class HttpAction : IHttpActionResult
        {
            Func<Task<HttpResponseMessage>> func = null;
            public HttpAction(Func<Task<HttpResponseMessage>> func) { this.func = func; }
            Task<HttpResponseMessage> IHttpActionResult.ExecuteAsync(CancellationToken cancellationToken) { return func(); }
        }
  This helper class allows us to use _async_ operations within the controller.

1. Modify the _TodoController_ class definition to inherit from _ApiController_:

        public sealed class TodoController : ApiController

1. Add some instance fields for our controller methods:

        TodoData data = null;
        IReliableObjectStateManager manager = null;

1. Add a constructor that accepts an _IReliableObjectStateManager_ instance and stores it for method use:

        public TodoController(IReliableObjectStateManager s)
        {
            this.manager = s;
        }

1. Now add the helper method to get our "Todo" queue:

        async Task<IReliableQueue<string>> GetQueueAsync()
        {
            return await manager.GetOrAddAsync<IReliableQueue<string>>("todo");
        }

1. Now let's implement the "add" method:

        [HttpPost, Route("add")]
        public IHttpActionResult Add([FromBody] TodoData data)
        {
            this.data = data;
            return new HttpAction(this.AddOperation);
        }
  So far we have only received the message, and saved away any incoming data.  But we then create a new _IHttpActionResult_ instance which calls our specified operation method, for asynchronous completion.

1. Now we can perform the actual "add" operation with the provided _IReliableObjectStateManager_ information, and the provided incoming "data" instance.

        async Task<HttpResponseMessage> AddOperation()
        {
            if (data == null || data.value == null)
              return this.Request.CreateResponse(new TodoError("no todo value supplied"));
            var queue = await GetQueueAsync();
            using (var tx = manager.CreateTransaction())
            {
                await queue.EnqueueAsync(tx, data.value);
                await tx.CommitAsync();
            }
            return this.Request.CreateResponse(new TodoResult(true));
        }
  Steps within the operation:
  1. Verify that the data was passed in correctly
  2. Get the instance of the _IReliableQueue_ that we are using
  3. Create a new transaction scope
  4. Add (Enqueue) the new item
  5. Commit the transaction
  6. Return the successful result
<br>
1. Now add the Remove method and Remove operation:

        [HttpGet, Route("remove")]
        public IHttpActionResult Remove() { return new HttpAction(this.RemoveOperation); }

        async Task<HttpResponseMessage> RemoveOperation()
        {
            var queue = await GetQueueAsync();
            string value = null;
            using (var tx = manager.CreateTransaction())
            {
                var cond = await queue.TryDequeueAsync(tx);
                if (cond.HasValue)
                    value = cond.Value;
                await tx.CommitAsync();
            }

            if (value == null)
                return this.Request.CreateResponse(new TodoResult(false));
            return this.Request.CreateResponse(new TodoValue(value));
        }

1. Now add the Peek method and Peek Operation:

        [HttpGet, Route("peek")]
        public IHttpActionResult Peek() { return new HttpAction(this.PeekOperation); }

        async Task<HttpResponseMessage> PeekOperation()
        {
            var queue = await GetQueueAsync();
            string value = null;
            using (var tx = manager.CreateTransaction())
            {
                var cond = await queue.TryPeekAsync(tx);
                if (cond.HasValue)
                    value = cond.Value;
                await tx.CommitAsync();
            }

            if (value == null)
                return this.Request.CreateResponse(new TodoResult(false));
            return this.Request.CreateResponse(new TodoValue(value));
        }

1. Save **TodoController.cs**.

## Modify Manifests

1. Open the **PackageRoot\ServiceManifest.xml** file in the **Todo** project.
2. Modify the **Endpoint** resource definition to read:

        <Endpoint Name="ServiceEndpoint" Protocol="http" Type="Input" />

3. Open the **AssemblyManifest.xml** file in the **TodoApplication** project.
4. After the **DefaultServices** section, replace the current:

        <Principals/>
    
    section with:

        <Principals>
            <Users>
            <User Name="PortUser" AccountType="NetworkService" />
            </Users>
        </Principals>
        <Policies>
            <DefaultRunAsPolicy UserRef="PortUser" />
        </Policies>

## Test locally

1. ![][2] If you haven't done so, you need to launch a local cluster first. Launch **Windows PowerShell** as **administrator** and execute the **DevClusterSetup.ps1** script under the **_DropLocation_\ClusterSetup\Local** folder.
<br/>
  **NOTE**: Your local cluster might be already running, in which case the script fails with many errors. If you want to clean up the local cluster, run the **CleanCluster.ps1** script under the same folder.

1. You can now build and deploy your service. Press **F5**, and your service is started. Once the service is running, you can see its output on the **Output** window of Visual Studio.
![][3]

1. You can now send data to the service, and receive a response, following the PowerShell script:

        $app = Get-ServiceFabricApplication -ApplicationName 'fabric:/TodoApplication'
        $service = $app | Get-ServiceFabricService
        $partition = $service | Get-ServiceFabricPartition
        $replicas = $partition | Get-ServiceFabricReplica
        $primary = $replicas | ? { $_.ReplicaRole -eq 'Primary' }
        $address = $primary.ReplicaAddress
        $item = @{ value = "foo" };
        $argsAdd = @{
            Uri = "$address/add";
            Body = ConvertTo-Json $item;
            Method = "Post";
            ContentType = "application/json";
            }
        Invoke-RestMethod @args 

1. To peek at the item that was just added:

        Invoke-RestMethod "$address/peek"

1. To remove the item that was just added:

        Invoke-RestMethod "$address/remove"

1. To peek at the next item (that doesn't exist):

        Invoke-RestMethod "$address/peek"

1. The outputs of the above commands look like the following:
![][7]
1. Stop the program.

  >**NOTE**: To debug locally, set break points at the lines of interest. 

## Conclusion

In this tutorial, you created a stateful service with reliable collections, and tested it locally.

<!--image references-->

[1]: ./media/service-fabric-get-started-todo-service-with-web-api/add-json.png
[2]: ./media/service-fabric-get-started-todo-service-with-web-api/change.png
[3]: ./media/service-fabric-get-started-todo-service-with-web-api/diag-events.png
[4]: ./media/service-fabric-get-started-todo-service-with-web-api/new-project.png
[5]: ./media/service-fabric-get-started-todo-service-with-web-api/new-sln.png
[6]: ./media/service-fabric-get-started-todo-service-with-web-api/psh-test.png
[7]: ./media/service-fabric-get-started-todo-service-with-web-api/response.png
[8]: ./media/service-fabric-get-started-todo-service-with-web-api/warn.png
[9]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-add.png
[10]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-install.png
[11]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-options.png
[12]: ./media/service-fabric-get-started-todo-service-with-web-api/web-api-setup.png
[13]: ./media/service-fabric-get-started-todo-service-with-web-api/file-listener.cs.txt
